<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="xsd.xsl" type="text/xsl"?>

<xs:schema targetNamespace="http://www.w3.org/2010/09/qt-fots-catalog" elementFormDefault="qualified" attributeFormDefault="unqualified" 
    xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.w3.org/2010/09/qt-fots-catalog">
    <xs:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="xml.xsd"
        xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"/>
    
    <xs:annotation>
        <xs:documentation>
            
                <h1>QT3 Test Suite Schema</h1>
                <p>
                    This schema documentation describes the elements and attributes
                    which are to be used in the catalog and test-set instance 
                    documents, and belong to the QT3 test suite (known during development as FOTS).
                </p>
                <p>QT3 derives from the W3C <a href="http://dev.w3.org/cvsweb/2007/xpath-full-text-10-test-suite/" target="_blank">XQuery</a> and 
                    <a href="http://dev.w3.org/2006/xquery-test-suite/PublicPagesStagingArea/" target="_blank">XSLT test suites</a>, where we 
                    intend to overcome the following problems with the existing test suites:
                    <ul>
                        <li>Duplication across the XSLT and XQuery test suites</li>
                        <li>Very large XQuery test suite which has become somewhat disorganised and cumbersome to find specific tests or
                            find all test for a particular function</li>
                        <li>Unavailability of the XSLT test suite to the general public</li>
                        <li>Serialization issues of the test results, where the comparing of canonicalized XML documents, is
                            unnecessarily cumbersome for the typical function test that returns an atomic value.</li>
                        <li>Usability problems for standalone XPath processors and other host languages that use XPath</li>
                        <li></li>
                    </ul>
                </p>
                <p>This schema describes two kinds of file: the master catalog file, rooted at a
                    <code>catalog</code> element, and test-set files, which are rooted at a <code>test-set</code>
                    element. The catalog file contains a sequence of <code>test-set</code> elements which are
                    references to the test-set files.</p>
             
            
        </xs:documentation>
    </xs:annotation>
    
    <xs:element name="catalog">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>catalog</h3>
                    <p>
                        Denotes the root element of the catalog document. 
                        The catalog lists all test-sets that are to be run and
                        also contains an environment of assorted schemas and source documents.
                    </p>
                </div> 
                              
            </xs:documentation>
        </xs:annotation>
        
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="environment" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="test-set" maxOccurs="unbounded">                    
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:extension base="baseType">
                                <xs:attributeGroup ref="nameAttr" />
                                <xs:attributeGroup ref="fileAttr" />
                             </xs:extension>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="version" type="xs:decimal">
                <xs:annotation>
                    <xs:documentation>
                        <p>Identifies the version of the test suite. Should be incremented each time
                            the test suite is released.</p>
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>    
            <xs:attribute name="test-suite" type="xs:string" >
               <xs:annotation>
                    <xs:documentation>
                        <p>Identifies this test suite (in case there are several test suites using this format)</p>
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>                   
        </xs:complexType>
    </xs:element>
    
    <xs:element name="environment">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>environment</h3>
                    <p>
                        Denotes an element which defines an assorted list of schemas and sources documents available to test cases.</p>
                        
                    <p> In addition the environment may set further information about the static context for running the test.</p>
                    
                    <p>    
                        An environment can be made globally available across all test-sets, 
                        or within a particular test-set or within a test-case.
                        Locally-defined environments are considered to have precedence over 
                        environments defined at some ancestor node, therefore conflicts are avoided.
                        
                    </p>
                    <p>
                        An environment that is shared between test cases always has a name (given by its <code>name</code> attribute).
                        An environment element within a test case may either be a reference to a shared environment (identified
                        by its <code>ref</code> attribute) or a locally-defined environment (with no <code>name</code> or <code>ref</code>
                        attributes.</p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="baseType">            
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="schema" />
                        <xs:element ref="source" />
                        <xs:element ref="resource" />
                        <xs:element ref="param" />
                        <xs:element ref="context-item" />
                        <xs:element ref="decimal-format" />
                        <xs:element ref="namespace" />
                        <xs:element ref="function-library" />
                        <xs:element ref="collection" />
                        <xs:element ref="static-base-uri" />
                        <xs:element ref="collation" />
                    </xs:choice>
                    <xs:attributeGroup ref="nameAttr" />
                    <xs:attributeGroup ref="refAttr" />
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="static-base-uri">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>static-base-uri</h3>
                    <p>An element used to supply the static base URI for a query. The <code>uri</code> attribute
                      should be an absolute URI.</p>
                    <p>In the absence of this element, or of a base URI declaration in the query prolog,
                    the static base URI of a query is the file containing the text of the query.</p>
                    <p>The value <code>uri='#UNDEFINED'</code> indicates that the test expects the static base URI
                    to be absent.</p>
                </div>
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="uriAttr" />
        </xs:complexType>
    </xs:element>
    
    <xs:element name="collation">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>collation</h3>
                    <p>An element which defines a collation URI used in the query.</p>
                        
                    <p>The <code>uri</code>
                        attribute is the collation URI as it actually appears in the XPath expression. There is
                        a small enumerated set of collation URIs that may appear in tests; these have a meaning
                        that is defined in the test suite. If the implementation cannot bind arbitrary URIs to
                        collations, it may substitute this URI in the source expression by a different one having
                        the same semantics. If the implementation does not support the semantics of the collation,
                        then it should not run the test (support for collations other than the codepoint collation
                        is not a conformance requirement. 
                    </p>
                    <p>The <code>default</code> attribute indicates whether this collation is to be used as the
                    default collation.</p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="uri">
                <xs:simpleType>
                    <xs:restriction base="xs:anyURI">
                        <xs:enumeration value="http://www.w3.org/2005/xpath-functions/collation/codepoint">
                            <xs:annotation>
                                <xs:documentation>
                                    <p>This is the standard codepoint collation which all implementations must support</p>
                                </xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                        <xs:enumeration value="http://www.w3.org/2010/09/qt-fots-catalog/collation/caseblind">
                            <xs:annotation>
                                <xs:documentation>
                                    <p>This URI is used to represent a case-blind collation. Tests using this collation
                                        will only use it to compare strings made up of ASCII letters (a-z, A-Z), and the
                                        only requirement placed on the collation is that (a) the comparison is case-blind
                                        (so "a"="A", "b"="B", etc), and different characters sort in the conventional
                                        order of the English alphabet ("a" &lt; "b", etc).</p>
                                </xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                    </xs:restriction>
                </xs:simpleType>
             </xs:attribute>
             <xs:attribute name="default" type="xs:boolean" use="optional" default="false">
                <xs:annotation>
                    <xs:documentation>
                        <p>The value <code>default="true"</code> indicates that this collation is to be the default collation
                        in the static context.</p>
                    </xs:documentation>
                </xs:annotation>
             </xs:attribute>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="decimal-format">
        <xs:annotation>
            <xs:documentation>
               <div> 
                <h3>decimal-format</h3>
                <p>The <code>decimal-format</code> element allows a decimal format to be defined as part of the 
                    static context for evaluating an XPath expression that calls the format-number() function.</p>
                    
                <p>When the <code>decimal-format</code> element is used in an environment, the test expression
                will always be a simple XPath expression. If the test is to be run using an XQuery processor, 
                the decimal format can be added to the static context either by using the processor's API, or
                by constructing a query prolog containing a <code>declare decimal format</code> declaration and
                prepending this to the test expression.</p>
                
                <p>The mechanism is used for testing the format-number() function. As such, the decimal format
                    being defined should always be valid. Tests for invalid decimal formats should be written
                    as XQuery tests with an explicit query prolog (or the equivalent in XSLT).</p>
                    
                <p>Test Catalog006 ensures that the decimal-format element is only used in tests that are
                    pure XPath expressions.</p>
              </div>
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="name" type="xs:QName"/>
            <xs:attribute name="decimal-separator" type="one-char"/>
            <xs:attribute name="grouping-separator" type="one-char"/>
            <xs:attribute name="zero-digit" type="one-char"/> 
            <xs:attribute name="digit" type="one-char"/>
            <xs:attribute name="minus-sign" type="one-char"/> 
            <xs:attribute name="percent" type="one-char"/>
            <xs:attribute name="per-mille" type="one-char"/>
            <xs:attribute name="pattern-separator" type="one-char"/>
            <xs:attribute name="infinity" type="xs:string"/>
            <xs:attribute name="NaN" type="xs:string"/>
        </xs:complexType>
    </xs:element>
    
    <xs:simpleType name="one-char">
        <xs:annotation>
            <xs:documentation>
                <p>A simple type representing a string whose length is exactly one character.</p>
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="." />
        </xs:restriction>
    </xs:simpleType>
               
    
    <xs:element name="param">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>param</h3>
                    <p>
                        An element within an environment that declares a variable that can be referenced
                        within test expressions that use this environment.
                    </p>
                    <p>The value to be bound to the variable is given in the select attribute, which should
                    be a simple XPath expression - typically a literal, or a simple call on a constructor function.</p>
                     <p>   
                        The test expression may or may not include a declaration of the variable (so it can be
                        executed if appropriate using XPath). The "declared" attribute will be present with the
                        value "true" if the variable is declared in the query prolog. The test driver can add a declaration of the
                        variable to the query prolog if required. If the test expression includes the string
                        "(:%VARDECL%:)" then the variable declaration should be added to replace this string;
                        if it does not include this string, the variable declaration can be added at the start.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="name" type="xs:NCName" use="required"/>
            <xs:attribute name="select" type="xs:string" use="optional"/>
            <xs:attribute name="as" type="xs:string" use="optional"/>
            <xs:attribute name="source" type="xs:string" use="optional"/>
            <xs:attribute name="declared" type="xs:boolean" use="optional" default="false"/>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="context-item">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>context-item</h3>
                    <p>
                        An element within an environment that declares the value of the context item
                        for a query.</p>
                    <p>The value to be bound to the variable is given in the select attribute, which should
                        be a simple XPath expression - typically a literal, or a simple call on a constructor function.</p>
                     <p>   
                        The query is called with the value of the select expression as the context item.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="select" type="xs:string" use="optional"/>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="collection">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>collection</h3>
                    <p>
                        Represents a collection accessible to the collection() function.
                    </p>
                    <p>The <code>uri</code> attribute identifies the collection URI. If this is
                       absent or zero-length, the collection acts as the default collection, used
                       when no URI is supplied to the <code>collection()</code> function.</p>
                       
                    <p>The contained <code>source</code> elements identify the documents making
                    up the collection.</p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="source" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attributeGroup ref="uriAttr"/>
        </xs:complexType>
    </xs:element>
       
    <xs:element name="function-library">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>function-library</h3>
                    <p>
                        An element which provides access to a function library defined for xslt and xquery.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="nameAttr" />
            <xs:attribute name="xslt-location" />
            <xs:attribute name="xquery-location" />
        </xs:complexType>
    </xs:element>
    
    <xs:element name="namespace">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>namespace</h3>
                    <p>
                        When this element is present in an environment, queries using this environment must
                        have a namespace binding in the static context that binds the specified prefix to the
                        specified namespace URI.</p>
                        
                    <p> A zero-length prefix denotes the default
                        namespace for elements and types.</p>
                        
                    <p>
                        All tests using an environment that contains a <code>namespace</code> element will
                        be simple XPath expressions, so that the test can be run either under XPath or XQuery.
                        If the test is run using an XPath processor, the namespace must be declared externally
                        using the processor's API. If it is run using an XQuery processor, the namespace can
                        either be declared externally using the processor's API, or a "declare namespace"
                        declaration can be added to the query prolog. Because the test is guaranteed to be a
                        simple XPath expression, adding the namespace declaration at the start is straightforward. </p>
                        
                    <p> Test Catalog005 checks that no test that requires XQuery uses an environment that contains
                        a namespace element. </p>
                        
                    
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="prefix" />
            <xs:attribute name="uri" />
        </xs:complexType>
    </xs:element>
    
    <xs:element name="schema" type="schemaType" >
    <xs:annotation>
        <xs:documentation>
            <div>
                <h3>schema</h3>
                <p>
                    An element which provides information about a schema to be used to validate a source document. 
                    The scope of the &lt;schema&gt; element is the parent &lt;environment&gt; element in which it appears.
                </p>
            </div> 
        </xs:documentation>
    </xs:annotation>
    </xs:element>
    
    <xs:complexType name="baseType" abstract="true">
        <xs:attribute ref="xml:id"/>
    </xs:complexType>
    
    <xs:complexType name="schemaType">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>schemaType</h3>
                    <p>
                        The type definition for the <code>schema</code> element
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="baseType">
                <xs:sequence >
                    <xs:element ref="description" minOccurs="0" maxOccurs="1"/>
                    <xs:element ref="created" minOccurs="0" maxOccurs="1"/>
                    <xs:element ref="modified" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attributeGroup ref="uriAttr" />
                <xs:attributeGroup ref="fileAttr" />
                <xs:attribute name="xsd-version" type="xs:decimal" default="1.0"/>
                <!--<xs:attributeGroup ref="lastModAttr" />-->
            </xs:extension>
            
        </xs:complexContent>
        
    </xs:complexType>
    
    <xs:element name="source" type="sourceType" >
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>source</h3>
                    <p>
                        An element which provides information about a source xml file used as input to test cases.</p>
                        
                        
                    <p> The <code>role</code> and <code>uri</code> attributes indicate how the source document is made
                    available to queries (as the context item, as the value of an external variable, or as a URI that can be
                    supplied to the doc() function.)</p>
                    
                    <p> The <code>file</code> attribute gives the relative location of the file containing the XML source.</p>
                    
                    <p> The scope of the &lt;source&gt; element is 
                        the parent &lt;environment&gt; element in which it appears. A validated source 
                        document references the schema, which maps to the @id of the Schema element. 
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        
    </xs:element>
    
    <xs:complexType name="sourceType">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>sourceType</h3>
                    <p>
                        defines the type of the <code>source</code> element.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="baseType">
                <xs:sequence>
                    <xs:element ref="description" minOccurs="0" maxOccurs="1"/>
                    <xs:element ref="created" minOccurs="0" maxOccurs="1"/>
                    <xs:element ref="modified" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attributeGroup ref="roleAttr"/>
                <xs:attributeGroup ref="fileAttr" />
                <xs:attributeGroup ref="uriAttr" />
                <xs:attributeGroup ref="validationAttr" />
           
            </xs:extension>
        </xs:complexContent>
        
    </xs:complexType>
    
    <xs:element name="resource" type="resourceType" >
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>resource</h3>
                    <p>
                        An element which provides information about a file that can be read as text, used as input to test cases.</p>
                        
                        
                    <p> The <code>uri</code> attributes indicate how the resource is made avaiable to queries (as a URI that can be supplied to the unparsed-text(), unparsed-text-lines() and unparsed-text-available() functions.)</p>
                    
                    <p> The <code>file</code> attribute gives the relative location of the file containing the resource.</p>

                    <p> The optional <code>media-type</code> attribute gives the media type of the resource.</p>

                    <p> The optional <code>encoding</code> attribute gives the name of the encoding of the resource.</p>
                    
                    <p> The scope of the &lt;resource&gt; element is 
                        the parent &lt;environment&gt; element in which it appears. A validated source 
                        document references the schema, which maps to the @id of the Schema element. 
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        
    </xs:element>
    
    <xs:complexType name="resourceType">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>resourceType</h3>
                    <p>
                        defines the type of the <code>resource</code> element.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="baseType">
                <xs:sequence>
                    <xs:sequence >
                    <xs:element ref="description" minOccurs="0" maxOccurs="1"/>
                    <xs:element ref="created" minOccurs="0" maxOccurs="1"/>
                    <xs:element ref="modified" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                </xs:sequence>
                <xs:attributeGroup ref="fileAttr" />
                <xs:attributeGroup ref="uriAttr" />
                <xs:attributeGroup ref="media-typeAttr"/>
                <xs:attributeGroup ref="encodingAttr"/>
           
            </xs:extension>
        </xs:complexContent>
        
    </xs:complexType>
    
    
    <xs:element name="description">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>description</h3>
                    <p>
                        An element which provides descriptive information about the
                        resource described by its parent element.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string">
                                        
                </xs:extension>
                
            </xs:simpleContent>
            
            
        </xs:complexType>
    </xs:element>
    
    <xs:element name="test-set">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>test-set</h3>
                    <p>
                        denotes an element which provides a sequence of test-case entries for a particular function. 
                        Within this element we provide data needed to run the test for that function.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:choice maxOccurs="unbounded">
                    <xs:element ref="description"/>
                    <xs:element ref="link" />
                    <xs:element ref="environment"/>
                    <xs:element ref="dependency"/>
                </xs:choice>
                <xs:element ref="test-case" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attributeGroup ref="nameAttr" />
            <xs:attributeGroup ref="coversAttr" />
        </xs:complexType>
    </xs:element>
    
    <xs:element name="dependency">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>dependency</h3>
                    <p>Indicates a dependency which must be satisfied in order for a test to be run.</p>
                    
                    <p>A dependency may be associated with an individual test case or with
                        a test-set. A dependency at the level of a test-set appplies to all test cases in
                        that test-set.</p> 
                        
                    <p>The attribute setting <code>satisfied="false"</code> indicates that the test should only
                    be run if the dependency is NOT satisfied.</p>
                    
                    <p>The set of recognized values appearing in the <code>value</code> attribute
                    depends on the content of the <code>type</code> attribute.</p>
                    
                    <p>The most commonly-used dependency is on the version of XPath or XQuery. This
                    is represented by a dependency with <code>type="spec"</code> whose corresponding
                    value is, for example <code>value="XQ10+ XP30+"</code> which indicates that the
                    test can be run with XQuery 1.0 or later, or XPath 3.0 or later. A test with
                    <code>value="XQ10"</code> should be run with an XQuery 1.0 processor only (typically,
                    an XQuery 3.0 processor will produce a different result, described in a separate
                    test case.)</p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="typeAttr" />
            <xs:attributeGroup ref="valueAttr" />
            <xs:attribute name="satisfied" type="xs:boolean" default="true">
                <xs:annotation>
                    <xs:documentation>
                        <p>The default value "true" indicates that the dependency must be satisified
                        for the test to run</p>
                        <p>The setting "false" indicates that the test should only be run if the
                        dependency is NOT satisfied. For example, this might be used in a test to
                        show what happens if a language (such as <code>lang="jp"</code> is requested
                        and the processor does not support that language.</p>
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="test-case">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>test-case</h3>
                    <p>
                        denotes an element that contains a test that must be run in a named environment, 
                        also contains the expected result and description of the test, including author 
                        and creation date.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="description" />
                <xs:element ref="created" />
                <xs:element ref="modified" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="environment" minOccurs="0"/>
                <xs:element ref="module" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="dependency" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="test" />
                <xs:element ref="result" />
            </xs:sequence>
            <xs:attributeGroup ref="nameAttr" />
            <xs:attributeGroup ref="coversAttr" />
        </xs:complexType>
    </xs:element>
    
    <xs:element name="test">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>test</h3>
                    <p>
                        The content of the element is an XPath or XQuery expression to be evaluated.                     
                    </p>
                    <p>
                        As an alternative to providing the content inline, it may be provided in an external
                        file referenced using the <code>file</code> attribute. This is done only exceptionally, where (a)
                        the query is unusually large, or (b) there is a need to test features that can only
                        be achieved with an external file, for example special encodings.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attribute name="file" type="xs:anyURI" use="optional"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>        
    </xs:element>
    
    <xs:element name="created">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>created</h3>
                    <p>
                        Provides details of the author and creation date of a test case, source document, schema, etc. 
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="byAttr" />
            <xs:attributeGroup ref="onAttr" />
        </xs:complexType>
    </xs:element>
    
    <xs:element name="modified">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>modified</h3>
                    <p>
                        Provides a record of changes made to a test case or other resource over time. 
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="byAttr" />
            <xs:attributeGroup ref="onAttr" />
            <xs:attributeGroup ref="changeAttr" />
        </xs:complexType>
    </xs:element>
    
    <xs:element name="module">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>module</h3>
                    <p>
                        Defines an XQuery library module imported by a test case. The module element gives the module
                        URI and the location of the module. The query will contain an "import module" declaration
                        referencing the same module URI, with no "at" location (except where the "at" attribute is being
                        specifically tested, in which case the results are undefined.)
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="uri" type="xs:anyURI"/>
            <xs:attribute name="file" type="xs:anyURI"/>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="result">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>result</h3>
                    <p>
                        denotes an element which provides an &lt;assert&gt; or &gt;error&lt; element pertaining the expected result. 
                        Alternatively assertions can appears as a list within &lt;any-of&gt; or &lt;all-of&gt; element. 
                        The meaning of these elements are self explantary.
                        
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="abstractAssertion"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    
    
    <xs:complexType name="SequenceOfAssertionsType">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>complexType for a sequence of assertions</h3>
                    <p>
                        
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="abstractAssertion" minOccurs="1" maxOccurs="unbounded"/>
            
        </xs:sequence>
    </xs:complexType>
    
    
    <xs:element name="any-of" type="SequenceOfAssertionsType" substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>any-of</h3>
                    <p>
                        denotes an element which provides a list of assertions. 
                        One or more of the assertions needs to prove true for the test to pass, 
                        but if all fail then the test fails.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
    </xs:element>
    
    <xs:element name="all-of" type="SequenceOfAssertionsType"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>all-of</h3>
                    <p>
                        denotes an element which provides a list of assertions that must be all satisfied, 
                        if any of the assertions proves to be false then the test fails.      
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
    </xs:element>
    
    <xs:element name="abstractAssertion" abstract="true" type="xs:anyType" >
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>abstractAssertion</h3>
                    <p>
                        Abstract superclass for the various kinds of assertion.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
    </xs:element>
    
    
    
    <xs:element name="assert" substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert</h3>
                    <p>
                        The assert element contains an XPath expression whose effective boolean
                        value must be true; usually the expression will use the variable $result
                        which references the result of the expression. 
                    </p>
                    <p>For example, <code>&lt;assert&gt;matches(string($result), '[0-9]{3}')&lt;/assert&gt;</code>
                    asserts that the result of the test expression is a three-digit number.</p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string" />
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="assert-eq"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert-eq</h3>
                    <p>
                        The assert element contains an XPath expression (usually a simple string or numeric literal) which must
                        be equal to the result of the test case under the rules of the XPath 'eq' operator. 
                    </p>
                    <p>For example, <code>&lt;assert-eq&gt;12&lt;/assert-eq&gt;</code>
                    asserts that the result of the test expression is an atomic value that compares
                    equal to the integer 12 (which means it might be the double value 12.0 or the
                    float value 12.0 or the untyped atomic value "12.0", for example).</p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string" />
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="assert-count"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert-count</h3>
                    <p>
                        Asserts that the result must be a sequence containing a given number of items.
                        The value of the element is an integer giving the expected length of the sequence.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:integer" />
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="assert-deep-eq"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert-deep-eq</h3>
                    <p>
                        Asserts that the result must be a sequence of atomic values that is deep-equal
                        to the supplied sequence under the rules of the deep-equal() function.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string" />
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="assert-permutation"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert-permutation</h3>
                    <p>
                        Asserts that the result must be a sequence of atomic values that 
                        has some permutation (reordering) that is deep-equal
                        to the supplied sequence under the rules of the deep-equal() function.
                    </p>
                    
                    <p>Note this implies that NaN is equal to NaN.</p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string" />
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="assert-xml"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert-xml</h3>
                    <p>
                        Asserts the result of the query by providing a serialization of the expression 
                        result using the default serialization parameters method="xml" indent="no" 
                        omit-xml-declaration="yes".</p>
                        
                    <p> Previously called assert-serialization.    
                        Note that this assertion is not used to test serialization; it is used
                        as a way of supplying the expected results of the query in the form of an XML
                        document.</p>
                        
                    <p> The assertion is true if the result of parsing and canonicalizing the XML
                        given in the body of the assert-xml element is the same (byte-for-byte) as
                        the result of canonicalizing the XML result of the query. As an alternative
                        to canonicalizing, the results may be compared using the fn:deep-equal()
                        function.</p>    
                        
                     <p>The value will not necessarily be a well-formed document (it may be a fragment). 
                        The comparison can be done by converting the string into a well-formed
                        document by adding a wrapper element.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attributeGroup ref="fileAttr"/>
                    <xs:attribute name="ignore-prefixes" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>
                                <p>If this attribute is present with the value "true", it indicates that
                                the serialized result contains system-generated prefixes which can lead to
                                ignorable differences between the actual result and the serialized result.</p>
                                <p>This attribute is rarely used, and should be avoided for new tests. Instead,
                                the test result should be expressed using assertions that take no account
                                of the namespace prefixes generated.</p>
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="serialization-matches"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>serialization-matches</h3>
                    <p>
                        Asserts the result of serializing the query matches a given regular
                        expression.</p>
                        
                    <p> The result of the query must be serialized using the serialization
                        options specified within the query (if any).</p>
                        
                    <p> The assertion is true if the output of the serializer (as a string)
                        matches the regular expression, when compared using the matches() function
                        with the specified flags. Note this is not an anchored match, unless
                        anchors are included within the regular expression itself.</p>    
                        
                     <p>Note that the serializer output is treated as a string; we have no way
                        of testing the encoding of serialized output when treated as an octet stream.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attributeGroup ref="fileAttr"/>
                    <xs:attribute name="flags" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>
                                <p>If this attribute is present it indicates that the regular expression
                                matching is to be performed with this value as the "flags" argument to
                                the fn:matches() function.</p>
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="assert-serialization-error"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert-serialization-error</h3>
                    <p>
                        Asserts that the query can be executed without error, but serializing the result
                        produces a serialization error. The expression result is serialized using the default
                        serialization parameters method="xml" indent="no" omit-xml-declaration="yes".
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attributeGroup ref="codeAttr" />
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="assert-empty"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert-empty</h3>
                    <p>
                        Asserts that the result of the test is an empty sequence.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
    </xs:element>
    
    <xs:element name="assert-type"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert-type</h3>
                    <p>
                        Asserts that the result of the test matches the sequence type given as the value
                        of the assert-type element.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string" />
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>
    
    <xs:element name="assert-true"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert-true</h3>
                    <p>
                        Asserts that the result of the test is the singleton boolean value true().
                        Note, the test expression must actually evaluate to true: this is not an assertion
                        on the effective boolean value.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
    </xs:element>
    
    <xs:element name="assert-false"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert-true</h3>
                    <p>
                        Asserts that the result of the test is the singleton boolean value false().
                        Note, the test expression must actually evaluate to false: this is not an assertion
                        on the effective boolean value.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
    </xs:element>
    
    <xs:element name="assert-string-value" substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>assert-string-value</h3>
                    <p>
                        Asserts that the result of the test, after conversion to a string by applying the expression
                        
                        string-join(for $r in $result return string($r), " ")
                        
                        is equal to the string value of the assert-string-value element. Note that this test cannot
                        be used if the result includes items that do not have a string value (elements with element-only
                        content; function items)
                        
                        If the normalize-space attribute is present with the value true, then both the string value of the query
                        result and the value of the assert-string-value
                        element should be processed as if by the XPath normalize-space() function before the comparison.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attribute name="normalize-space" type="xs:boolean" default="false"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
        
    </xs:element>
    
    <xs:element name="error"  substitutionGroup="abstractAssertion">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>error</h3>
                    <p>
                        Asserts that the test is expected to fail with a static or dynamic error condition. 
                        The "code" attribute gives the expected error code.
                    </p>
                    <p>
                        For the purpose of official test reporting, an implementation is considered to pass a test
                        if the test expects and error and the implementation raises an error, regardless whether
                        the error codes match. Implementors are advised, however, that raising the wrong error code
                        often indicates a problem, so it is advisable to detect this situation. When reporting
                        requirements are finalized, we will be asking implementors to indicate tests which passed
                        but raised a different error, so that we can assess the extent to which implementations are
                        interoperable at the level of error codes.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="codeAttr" />
        </xs:complexType>
    </xs:element>
    
    <xs:element name="link">
        
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>link</h3>
                    <p>
                        denotes an element which provides reference to documentation of the function.
                    </p>
                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="typeAttr" />
            <xs:attributeGroup ref="documentAttr"/>
            <xs:attribute name="idref" type="xs:NCName" />
            <xs:attribute name="section-number">
                <xs:simpleType>
                    <xs:restriction base="xs:string">
                        <xs:pattern value="[0-9A-Z](\.*[0-9]+)*"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    
    <xs:attributeGroup name="documentAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>document (as an attribute name)</h3>
                        <p>
                            denotes an attribute which provides a URI to be used as reference to specification.
                        </p>
                    </div> 
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="document" type="xs:anyURI"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="codeAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>code (as an attribute name)</h3>
                        <p>
                            denotes an attribute which in most cases provides a NCName to be used as an error code 
                            in the scope of a error element. The attribute gives the local name of the
                            error code; the code is assumed to be in the standard error namespace.</p>
                        <p> The value "*" indicates that any error code is allowed.</p>
                        <p> The value may also be an EQName (Q{uri}local) to allow for user-defined error codes </p>
                    </div> 
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="code">
            <xs:simpleType>
                <xs:union memberTypes="xs:NCName EQName">
                    <xs:simpleType>
                        <xs:restriction base="xs:string">
                            <xs:annotation>
                                <xs:documentation>
                                    <p>code="*" means that any error code is allowed</p>
                                </xs:documentation>
                            </xs:annotation>
                            <xs:enumeration value="*"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:union>
            </xs:simpleType>    
        </xs:attribute>
    </xs:attributeGroup>
    
    <xs:simpleType name="EQName">
      <xs:annotation>
        <xs:documentation>
          <p>Allows a user-defined error code to be expressed in the form Q{uri}local</p>
        </xs:documentation>
      </xs:annotation>
      <xs:restriction base="xs:string">
        <xs:pattern value="Q\{.*\}\i\c*"/>
      </xs:restriction>
    </xs:simpleType>
    
    <xs:attributeGroup name="fileAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>file</h3>
                        <p>
                            This attribute provides a URI to be used as location of a resource within
                            the test suite (for example, a source document, a query, a module, or a schema).
                        </p>
                        <p> The URI will always be relative to the base URI of the XML document in which
                            the attribute appears.
                        </p>
                    </div> 
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="file" type="xs:anyURI" use="optional"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="roleAttr">
                    <xs:annotation>
                        <xs:documentation>
                           <div>
                            <h3>role</h3> 
                            <p>Describes how a source document is made available to the query.</p>
                            <p>The value "." indicates that the source document will be the context
                            item for the query.</p>
                            <p>A value in the form <code>$varname</code> indicates that the source document will
                            be made available as the value of the external variable <code>$varname</code>. This variable
                            will <i>not</i> be declared in the query (this is to allow the mechanism
                            to be used in XPath). The query will always be such that it is possible to
                            add <code>declare variable</code> declarations at the start before compiling the query.</p>
                            <p>If the source document is to be made available to the query using the
                            doc() function, the "source" element should have a "uri" attribute, and
                            the "role" attribute should be absent.</p>
                            <p>The "role" attribute should be omitted if the source is part of a collection
                            definition.</p>
                           </div>
                        </xs:documentation>
                    </xs:annotation>
        <xs:attribute name="role" type="xs:string" use="optional"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="nameAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>name</h3>
                        <p>
                            An attribute used to provide a string that uniquely names an object within some scope.
                        </p>
                    </div> 
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="name" type="xs:string"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="coversAttr">
        <xs:annotation>
            <xs:documentation>
                <div>
                    <h3>covers</h3>
                    <p>
                        An attribute used to cross-reference tests or test-sets to the changes in the specification
                        that the tests are designed to cover.
                    </p>
                    <p> The value is syntactically similar to an xs:IDREFS value, in that it contains a space-separated
                    list of change identifiers; however it is not actually an xs:IDREFS value, because the identfiers are
                    in a different XML document, specifically the identifiers of changes appearing in the changes.xml file.</p>

                </div> 
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="covers" use="optional">
            <xs:simpleType>
                <xs:list itemType="xs:NCName"/>
            </xs:simpleType>
        </xs:attribute>    
    </xs:attributeGroup>
    
    <xs:attributeGroup name="creatorAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>creator</h3>
                        <p>
                            An attribute used to name the creator of a test-case.
                        </p>
                        <p>Use of this attribute does not constitute a claim to intellectual property rights.</p>
                        <p>The recommended form is as a personal name (first name, last name). An institutional name
                            may be used if policy requires it.</p>
                    </div> 
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="creator" type="xs:string"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="refAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>ref</h3>
                        <p>
                            denotes an attribute which contains a reference to an object defined
                            elsewhere in the test catalog, for example a reference to a named
                            environment.
                        </p>
                        <p>Note, this is not typed as xs:IDREF because the reference might be to an
                        object in a different XML document.</p>
                    </div> 
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="ref" type="xs:string"/>
     </xs:attributeGroup>
    
   
    <xs:attributeGroup name="validationAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>validation</h3>
                        <p>
                            indicates for a source document within an environment whether the source document is to be validated against
                            the schema defined for that environment, and if so whether validation is to be strict or lax.
                        </p>
                    </div> 
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="validation" type="validationEnumType" use="optional"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="media-typeAttr">
                    <xs:annotation>
                        <xs:documentation>
                           <div>
                            <h3>media-type</h3> 
                            <p>Describes the media type of a resource.</p>
                            <p>The value should conform to RFC 2046.</p>
                           </div>
                        </xs:documentation>
                    </xs:annotation>
        <xs:attribute name="media-type" type="xs:string" use="optional"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="encodingAttr">
                    <xs:annotation>
                        <xs:documentation>
                           <div>
                            <h3>encoding</h3> 
                            <p>Describes the encoding of a resource.</p>
                            <p>The value should be that of a character set registered with the Internet Assigned Numbers Authority.</p>
                           </div>
                        </xs:documentation>
                    </xs:annotation>
        <xs:attribute name="encoding" type="encodingType" use="optional"/>
    </xs:attributeGroup>
    
    <xs:simpleType name="encodingType">
      <xs:restriction base="xs:string">
	    <xs:pattern value="[A-Za-z]([A-Za-z0-9._-])*"/>
      </xs:restriction>
    </xs:simpleType>

    <xs:attributeGroup name="typeAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>type</h3>
                        <p>
                            The <code>type</code> attribute of a <code>dependency</code> element indicates what type of dependency
                            it is: the set of possible values is enumerated.
                        </p>
                        <p>
                            The most common <code>type</code> is <code>spec</code>, which indicates a dependency on specific versions of
                            XPath or XQuery. In this case the corresponding <code>value</code> attribute is a space-separated list
                            whose tokens are, for example, "XQ10" indicating XQuery 1.0, "XQ10+" indicating XQuery 1.0 or later, 
                            "XQ30+" indication XQuery 3.0 or later, or "XP20+" indicating XPath 2.0 or later. The tokens in the list
                            are alternatives; the test may be run if any of the dependencies is satisfied.
                        </p>
                        <p>Similarly, if the <code>type</code> is <code>xml-version</code>, the corresponding value is a space-separated
                        list whose tokens are "1.0" (XML 1.0), "1.1" (XML 1.1), "1.0:5+" (1.0, 5th edition or later), "1.0:4-" (1.0,
                        fourth edition or earlier).</p>
                    </div> 
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="type" type="dependencyEnumType"/>
    </xs:attributeGroup>
    
    <xs:simpleType name="dependencyEnumType">
        <xs:restriction base="xs:normalizedString">
            <xs:enumeration value="calendar" />
            <xs:enumeration value="collection-stability" />
            <xs:enumeration value="default-language" />
            <xs:enumeration value="directory-as-collection-uri" />
            <xs:enumeration value="feature" />
            <xs:enumeration value="format-integer-sequence" />
            <xs:enumeration value="language" />
            <xs:enumeration value="limits" />
            <xs:enumeration value="spec" />
            <xs:enumeration value="schemaAware" />
            <xs:enumeration value="unicode-normalization-form" />
            <xs:enumeration value="xml-version" />
            <xs:enumeration value="xsd-version" />
        </xs:restriction>
    </xs:simpleType>
    
    <xs:simpleType name="validationEnumType">
        <xs:restriction base="xs:normalizedString">
            <xs:enumeration value="strict" />
            <xs:enumeration value="lax" />
            <xs:enumeration value="skip" />
        </xs:restriction>
    </xs:simpleType>
    
    
    <xs:attributeGroup name="valueAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>value</h3>
                        <p>
                            As an attribute of the <code>dependency</code> element,
                            provides a string value to be used to indicate the dependency.
                        </p>
                    </div> 
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="value" type="xs:string"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="uriAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>uri (as an attribute name)</h3>
                        <p>
                            This attribute provides a URI to be used as an abstract identifier of a resource within
                            the test suite (for example, a source document, or a module). The URI is designed to
                            be independent of the location of the resource.
                        </p>
                         <p> The URI may be an absolute URI or a relative URI reference. If it is a relative URI reference,
                        it is resolved relative to the base URI of the element in which it appears (in practice, that is, the
                        base URI of the test-set catalog file).
                        </p>
                        <p>For source documents, the URI can be used in a call to the doc() function to retrieve
                            this source document (so the actual query does not need to know its location.</p>
                        <p>For modules, the URI defines the module URI and is again independent of location.</p>
                        <p>For schemas, the URI defines the target namespace URI.</p>
                    </div> 
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="uri" type="xs:anyURI"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="byAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>by (as an attribute name)</h3>
                        <p>
                            The name of the person who created or modified a test-case or source document, schema etc.
                        </p>
                        
                    </div> 
                    
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="by" type="xs:string"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="onAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>on (as an attribute name)</h3>
                        <p>
                            The date of an event such as the creation or modification of a test-case.
                        </p>
                        
                    </div> 
                    
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="on" type="xs:date"/>
    </xs:attributeGroup>
    
    <xs:attributeGroup name="changeAttr">
        <xs:annotation>
                <xs:documentation>
                    <div>
                        <h3>change (as an attribute name)</h3>
                        <p>
                            Textual explanation of a change made to a test-case.
                        </p>
                        
                    </div> 
                    
                </xs:documentation>
            </xs:annotation>
        <xs:attribute name="change" type="xs:string"/>
    </xs:attributeGroup>
</xs:schema>
